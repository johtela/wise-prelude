Parsec/Parser«import«Control/Monad¸ Math/Arith¸ Parsec/Lexer»¸ "# Parser

This module defines the basic types and combinators for the parser monad. To learn about monadic parsers refer to the list of literature in the [Wikipedia page](https://en.wikipedia.org/wiki/Parser_combinator).
"¸ type«"## Parser Result

The parser's result is a discriminated union that indicates either success or failure, along with the position in the input stream.

- On success, the parser returns `Ok`, which includes the parsed value of type `a` and the position where parsing ended.

- On failure, the parser returns `Fail`, including the position of the error, a string containing the erroneous input, and an array of inputs that were expected at that point.
"¸ data«ParseResult«a»¸ |«.Ok«Number¸ a»¸ .Fail«Number¸ String¸ [«String»»»»¸ "## Parsing Function
 
The `Parser(a, i)` type encapsulates a parsing function that takes a `ParserInput(i)` stream as input and produces a `ParseResult(a)` as the result. The type parameters `a` and `i` specify the type of the parsed value (`a`) and the type of the terminals in the input stream (`i`)."¸ data«Parser«a¸ i»¸ .Parse«->«ParserInput«i»¸ ParseResult«a»»»»»¸ define«"## Parser Monad

The monadic bind operator runs a parser `p` and, if successful, passes its result to the `binder` function. The `binder` function then returns a new parser to continue the parsing process. This operation is fundamental for combining parsers and serves as the building block for other combinators.
"¸ parseBind«->«p¸ binder¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«.Parse«pf1»¸ p»¸ match«pf1«input»¸ |«.Ok«_¸ res1»¸ do«let«.Parse«pf2»¸ binder«res1»»¸ let«res2¸ pf2«input»»¸ match«res2¸ |«.Fail«_¸ _¸ _»¸ do«.«input¸ setPosition«pos»»¸ res2»»¸ |«_¸ res2»»»»¸ |«.Fail«fpos¸ found¸ expected»¸ .Fail«fpos¸ found¸ expected»»»»»»»»¸ "Monadic return constructs a parser that always succeeds and returns the given value without consuming any input."¸ parseRet«->«val¸ .Parse«->«input¸ .Ok«\!«.«input¸ position»»¸ val»»»»»¸ "The opposite of return is `parseFail` which returns a failure result with specified arguments."¸ parseFail«->«found¸ expected¸ .Parse«->«input¸ .Fail«\!«.«input¸ position»»¸ found¸ [«expected»»»»»»»¸ instance«"Implement Monad and Functor type classes using above functions."¸ Monad«Parser¸ >>=«->>«p¸ binder¸ parseBind«p¸ binder»»»¸ _return«->>«val¸ parseRet«val»»»»¸ Functor«Parser¸ _map«->>«p¸ mapper¸ >>=«p¸ ->«val¸ _return«mapper«val»»»»»»»»¸ define«"## Conditional Parsing

The ordered choice operation. Create a parser that first runs parser `p1`, and if that fails, runs the `p2`. Corresponds to the `/` operation in PEG grammars.


A special case that all conditional parsers must handle is to return `.Fail` if input position has changed. This indicates the caller that it must backtrack in order to ""undo"" the parsing operation."¸ or«->«Parser«a¸ b»¸ Parser«a¸ b»¸ Parser«a¸ b»»¸ ->«.Parse«p1»¸ .Parse«p2»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res1¸ p1«input»»¸ match«res1¸ |«.Ok«_¸ _»¸ res1»¸ |«.Fail«fpos¸ _¸ _»¸ >«fpos¸ pos»¸ res1»¸ |«.Fail«_¸ _¸ expected1»¸ do«let«res2¸ p2«input»»¸ match«res2¸ |«.Ok«_¸ _»¸ res2»¸ |«.Fail«fpos¸ found¸ expected2»¸ .Fail«fpos¸ found¸ @+«expected1¸ expected2»»»»»»»»»»»»¸ "Run a parser and return either its value or `Null` if parsing fails."¸ optional«->«Parser«a¸ b»¸ Parser«?«a»¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ match«p«input»¸ |«.Ok«spos¸ val»¸ .Ok«spos¸ ?«val»»»¸ |«.Fail«fpos¸ _¸ _»¸ ==«fpos¸ pos»¸ .Ok«fpos¸ Null»»¸ |«.Fail«fpos¸ found¸ expected»¸ .Fail«fpos¸ found¸ expected»»»»»»»»¸ "Any of the given parsers must succeed. The operation is the same as the `or` combinator generalized to arbitrary number of choices."¸ any«->«[«Parser«a¸ b»»¸ Parser«a¸ b»»¸ ->«parsers¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«last¸ -«@length«parsers»¸ 1»»¸ letrec«iterate¸ ->«i¸ expected¸ do«let«.Parse«p»¸ @«parsers¸ i»»¸ let«res¸ p«input»»¸ match«res¸ |«.Ok«_¸ _»¸ res»¸ |«.Fail«fpos¸ _¸ _»¸ >«fpos¸ pos»¸ res»¸ |«.Fail«_¸ _¸ exp»¸ <«i¸ last»¸ iterate«+«i¸ 1»¸ [«...«exp»¸ ...«expected»»»»¸ |«.Fail«fpos¸ found¸ exp»¸ .Fail«fpos¸ found¸ [«...«exp»¸ ...«expected»»»»»»»»¸ if«>=«last¸ 0»¸ iterate«0¸ [»¸ throw«"At least one parser must be specified"»»»»»»»¸ "## Parsing Multiple Items

Create a parser that will run this parser zero or more times. The results of the input parser are collected to an array."¸ zeroOrMore«->«Parser«a¸ b»¸ Parser«[«a»¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«letrec«iterate¸ ->«list¸ do«let«pos¸ \!«.«input¸ position»»»¸ match«p«input»¸ |«.Ok«_¸ val»¸ do«Array:«.push«list¸ val»»¸ iterate«list»»»¸ |«.Fail«fpos¸ found¸ expected»¸ >«fpos¸ pos»¸ .Fail«fpos¸ found¸ expected»»¸ |«_¸ .Ok«pos¸ list»»»»»»¸ iterate«[»»»»»»¸ "Run parser `p` one or more times."¸ oneOrMore«->«Parser«a¸ b»¸ Parser«[«a»¸ b»»¸ ->«p¸ mdo«mlet«first¸ p»¸ mlet«rest¸ zeroOrMore«p»»¸ mreturn«[«first¸ ...«rest»»»»»»¸ "Succeeds if parser `p` succeeds from `min` to `max` times."¸ occurrences«->«Parser«a¸ b»¸ Number¸ Number¸ Parser«[«a»¸ b»»¸ ->«p¸ min¸ max¸ >>=«zeroOrMore«p»¸ ->«list¸ do«let«cnt¸ @length«list»»¸ if«&&«>=«cnt¸ min»¸ <=«cnt¸ max»»¸ parseRet«list»¸ parseFail«_concat«[«_show«cnt»¸ " occurrences"»»¸ _concat«[«"between "¸ _show«min»¸ " and "¸ _show«max»¸ " occurrences"»»»»»»»»»¸ "## Lookahead & Backtracking

Check that this parser succeeds without consuming any input. This function corresponds to the `&` operator in PEG grammars.
"¸ and«->«Parser«a¸ b»¸ Parser«a¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res¸ p«input»»¸ .«input¸ setPosition«pos»»¸ res»»»»»¸ "Check that a parser fails without consuming any input. Corresponds to the `!` operator in PEG grammars."¸ not«->«Parser«a«Show»¸ b»¸ Parser«Unit¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res¸ p«input»»¸ .«input¸ setPosition«pos»»¸ match«res¸ |«.Ok«spos¸ val»¸ do«let«found¸ _show«val»»¸ .Fail«spos¸ found¸ [«_concat«[«"not "¸ found»»»»»»¸ |«.Fail«fpos¸ _¸ _»¸ .Ok«fpos¸ ()»»»»»»»»¸ "Bactrack to the current input position, if parser `p` fails and has advanced the input position. Normally we do not bactrack when a parser has advanced in the input. Doing so would loose the position where the parsing failed and make error messages more vague. Sometimes, however, we need more input lookahead. In these cases, you can use the backtrack operation to retry the next rule."¸ backtrack«->«Parser«a¸ b»¸ Parser«a¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res¸ p«input»»¸ match«res¸ |«.Fail«fpos¸ _¸ _»¸ >«fpos¸ pos»¸ do«.«input¸ setPosition«pos»»¸ res»»¸ |«_¸ res»»»»»»»¸ "## Error Reporting and Debugging

Give a human-readable name to the ""thing"" that parser `p` matches. This name is reported as expected value, if the parsing fails."¸ expect«->«.Parse«p»¸ expected¸ .Parse«->«input¸ do«let«res¸ p«input»»¸ match«res¸ |«.Fail«fpos¸ found¸ exp»¸ .Fail«fpos¸ found¸ [«expected¸ ...«exp»»»»¸ |«_¸ res»»»»»»»¸ "## Parsing Terminals

Create a parser that reads one terminal from the input and returns it, if it satisfies the given predicate; otherwise the parser fails."¸ satisfy«->«->«a«Show»¸ Bool»¸ String¸ Parser«a¸ a»»¸ ->«predicate¸ expected¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«tok¸ \!«.«input¸ next»»»¸ if«predicate«tok»¸ .Ok«\!«.«input¸ position»»¸ tok»¸ do«.«input¸ setPosition«pos»»¸ .Fail«\!«.«input¸ position»»¸ _show«tok»¸ [«expected»»»»»»»»»¸ "Peek next symbol in the input stream without changing the position."¸ peek«Parser«a¸ a»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«next¸ \!«.«input¸ next»»»¸ .«input¸ setPosition«pos»»¸ .Ok«pos¸ next»»»»»¸ "Select a parser to be used based on the next symbol in the input. This function is an alternative to the the ""any"" combinator. It reduces backtracking when the parser to be applied can be deduced from the next symbol."¸ choose«->«->«a¸ Parser«b¸ c»»¸ Parser«b¸ c»»¸ ->«selector¸ >>=«peek¸ selector»»»¸ "## Get Current Position

A parser that returns the current position of the input. This is useful when binding parsers together and you want to know the position where you currently are. The position can be also used for backtracking.
"¸ position«Parser«Number¸ a»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ .Ok«pos¸ pos»»»»»¸ "## General Parsers

The catch-all parser that will match any symbol read from the input."¸ anything«Parser«a«Show»¸ a»¸ satisfy«->«_¸ true»¸ "anything"»»¸ "Parser that succeeds if the symbol read from the input is equal to given parameter; otherwise parsing fails."¸ is«->«a«Eq¸ Show»¸ Parser«a¸ a»»¸ ->«value¸ satisfy«->«a¸ ==«a¸ value»»¸ _show«value»»»»¸ "Parse a specified token from the lexer input stream."¸ terminal«->«Token«a«Eq»»¸ String¸ Parser«Token«a»¸ Token«a»»»¸ ->«.Token«sym¸ _»¸ expected¸ satisfy«->«.Token«s¸ _»¸ ==«s¸ sym»»¸ expected»»»»»