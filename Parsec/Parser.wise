Parsec/Parser«import«Control/Monad¸ Parsec/Input»¸ ---«"# Parser

This module defines the basic types and combinators for the parser monad. To learn about monadic parsers refer to the list of literature in the [Wikipedia page](https://en.wikipedia.org/wiki/Parser_combinator).
"»¸ type«---«"## Parser Result

The parser's result is a discriminated union that indicates either success or failure, along with the position in the input stream.

- On success, the parser returns `Ok`, which includes the parsed value of type `a` and the position where parsing ended.

- On failure, the parser returns `Fail`, including the position of the error, a string containing the erroneous input, and an array of inputs that were expected at that point.
"»¸ data«ParseResult«a»¸ |«.Ok«Number¸ a»¸ .Fail«Number¸ String¸ [«String»»»»¸ ---«"## Parsing Function
 
The `Parser(a, i)` type encapsulates a parsing function that takes a `ParserInput(i)` stream as input and produces a `ParseResult(a)` as the result. The type parameters `a` and `i` specify the type of the parsed value (`a`) and the type of the terminals in the input stream (`i`)."»¸ data«Parser«a¸ i»¸ .Parse«->«ParserInput«i»¸ ParseResult«a»»»»»¸ define«---«"## Parser Monad

The monadic bind operator `>>=` runs a parser (`p`) and, if successful, passes its result to the `binder` function. The `binder` function then returns a new parser to continue the parsing process. This operation is fundamental for combining parsers and serves as the building block for other combinators.

Monadic `_return` constructs a parser that always succeeds and returns the given value without consuming any input."»¸ parseBind«->«p¸ binder¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«.Parse«pf1»¸ p»¸ match«pf1«input»¸ |«.Ok«_¸ res1»¸ do«let«.Parse«pf2»¸ binder«res1»»¸ let«res2¸ pf2«input»»¸ match«res2¸ |«.Fail«_¸ _¸ _»¸ do«.«input¸ setPosition«pos»»¸ res2»»¸ |«_¸ res2»»»»¸ |«.Fail«fpos¸ found¸ expected»¸ .Fail«fpos¸ found¸ expected»»»»»»»»¸ parseRet«->«val¸ .Parse«->«input¸ .Ok«\!«.«input¸ position»»¸ val»»»»»¸ parseFail«->«found¸ expected¸ .Parse«->«input¸ .Fail«\!«.«input¸ position»»¸ found¸ [«expected»»»»»»»¸ instance«Monad«Parser¸ >>=«->>«p¸ binder¸ parseBind«p¸ binder»»»¸ _return«->>«val¸ parseRet«val»»»»¸ Functor«Parser¸ _map«->>«p¸ mapper¸ >>=«p¸ ->«val¸ _return«mapper«val»»»»»»»»¸ define«---«"## Conditional Parsing

The ordered choice operation. Create a parser that first runs parser `p1`, and if that fails, runs the `p2`. Corresponds to the `/` operation in PEG grammars.


A special case that all conditional parsers must handle is to return `.Fail` if input position has changed. This indicates the caller that it must backtrack in order to ""undo"" the parsing operation."»¸ or«->«Parser«a¸ b»¸ Parser«a¸ b»¸ Parser«a¸ b»»¸ ->«.Parse«p1»¸ .Parse«p2»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res1¸ p1«input»»¸ match«res1¸ |«.Ok«_¸ _»¸ res1»¸ |«.Fail«fpos¸ _¸ _»¸ >«fpos¸ pos»¸ res1»¸ |«.Fail«_¸ _¸ expected1»¸ do«let«res2¸ p2«input»»¸ match«res2¸ |«.Ok«_¸ _»¸ res2»¸ |«.Fail«fpos¸ found¸ expected2»¸ .Fail«fpos¸ found¸ @+«expected1¸ expected2»»»»»»»»»»»»¸ ---«"Optionally run a parser and return either its value or `Null` if parsing fails."»¸ optional«->«Parser«a¸ b»¸ Parser«?«a»¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ match«p«input»¸ |«.Ok«spos¸ val»¸ .Ok«spos¸ ?«val»»»¸ |«.Fail«fpos¸ _¸ _»¸ ==«fpos¸ pos»¸ .Ok«fpos¸ Null»»¸ |«.Fail«fpos¸ found¸ expected»¸ .Fail«fpos¸ found¸ expected»»»»»»»»¸ ---«"## Parsing Multiple Items

Create a parser that will run this parser zero or more times. The results of the input parser are collected to an array."»¸ zeroOrMore«->«Parser«a¸ b»¸ Parser«[«a»¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«letrec«iterate¸ ->«list¸ do«let«pos¸ \!«.«input¸ position»»»¸ match«p«input»¸ |«.Ok«_¸ val»¸ do«Array:«.push«list¸ val»»¸ iterate«list»»»¸ |«.Fail«fpos¸ found¸ expected»¸ >«fpos¸ pos»¸ .Fail«fpos¸ found¸ expected»»¸ |«_¸ .Ok«pos¸ list»»»»»»¸ iterate«[»»»»»»¸ ---«"Create a parser that runs parser `p` one or more times."»¸ oneOrMore«->«Parser«a¸ b»¸ Parser«[«a»¸ b»»¸ ->«p¸ mdo«mlet«first¸ p»¸ mlet«rest¸ zeroOrMore«p»»¸ mreturn«[«first¸ ...«rest»»»»»»¸ ---«"Parser that succeeds if parser `p` succeeds from `min` to `max` times."»¸ occurrences«->«Parser«a¸ b»¸ Number¸ Number¸ Parser«[«a»¸ b»»¸ ->«p¸ min¸ max¸ >>=«zeroOrMore«p»¸ ->«list¸ do«let«cnt¸ @length«list»»¸ if«&&«>=«cnt¸ min»¸ <=«cnt¸ max»»¸ parseRet«list»¸ parseFail«_concat«[«_show«cnt»¸ " occurrences"»»¸ _concat«[«"between "¸ _show«min»¸ " and "¸ _show«max»¸ " occurrences"»»»»»»»»»¸ ---«"## Lookahead & Backtracking

Check that this parser succeeds without consuming any input. This function corresponds to the `&` operator in PEG grammars.
"»¸ and«->«Parser«a¸ b»¸ Parser«a¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res¸ p«input»»¸ .«input¸ setPosition«pos»»¸ res»»»»»¸ ---«"Check that a parser fails without consuming any input. Corresponds to the `!` operator in PEG grammars."»¸ not«->«Parser«a«Show»¸ b»¸ Parser«Unit¸ b»»¸ ->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res¸ p«input»»¸ .«input¸ setPosition«pos»»¸ match«res¸ |«.Ok«spos¸ val»¸ do«let«found¸ _show«val»»¸ .Fail«spos¸ found¸ [«_concat«[«"not "¸ found»»»»»»¸ |«.Fail«fpos¸ _¸ _»¸ .Ok«fpos¸ ()»»»»»»»»¸ ---«"Bactrack to the current input position, if parser `p` fails and has advanced the input position. Normally we do not bactrack when a parser has advanced in the input. Doing so would loose the position where the parsing failed and make error messages more vague. Sometimes, however, we need more input lookahead. In these cases, you can use the backtrack operation to retry the next rule."»¸ backtrack«->«.Parse«p»¸ .Parse«->«input¸ do«let«pos¸ \!«.«input¸ position»»»¸ let«res¸ p«input»»¸ match«res¸ |«.Fail«fpos¸ _¸ _»¸ >«fpos¸ pos»¸ do«.«input¸ setPosition«pos»»¸ res»»¸ |«_¸ res»»»»»»»»»