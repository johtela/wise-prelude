Data/Monoid«import«Math/Arith»¸ class«"# Monoids

_Monoid_ captures the mathematical concept of structures that can be combined associatively with an identity element. It provides a common interface for ""combining things"" in a predictable way.

A monoid has two methods `_mempty` and `_mappend`. The first one returns an empty or zero value of the type. When an empty value is appended to a monoid the result will be the original monoid.

$$""_mappend""(m, ""_mempty"") = m$$


The `_mappend` operation combines two monoids. It has to be associative:

$$|:: ""_mappend""(""_mappend""(m1, m2), m3)} =;;
""_mappend""(m1, ""_mappend""(m2, m3)) ::|$$
"¸ Monoid«a¸ _mempty«a»¸ _mappend«->>«a¸ a¸ a»»»»¸ type«"## Bool Monoids


Bools can be combined by conjuction (`and`) or disjunction (`or`) operations. We define product types All and Any that contain boolean values and implement Monoid class for both. This way we can choose how we want to append boolean values by wrapping them in appropriate type.


Note that in runtime, single item product types are stripped to just to values that they contain. So there is no overhead when wrapping Bools into All and Any types."¸ data«All¸ _all«Bool»»¸ data«Any¸ _any«Bool»»¸ "## Number Monoids

Similarily, we define types Sum and Prod for numbers to allow for two different monoid implementations for `+` and `*` operations. We can't define division as a monoid append operator, since it's not associative operation."¸ data«Sum¸ _sum«Number»»¸ data«Prod¸ _prod«Number»»»¸ instance«"Here are the instances for types defined above."¸ Monoid«All¸ _mempty«_all«true»»¸ _mappend«->>«a1¸ a2¸ do«let«_all«b1»¸ a1»¸ let«_all«b2»¸ a2»¸ _all«&&«b1¸ b2»»»»»»¸ Monoid«Any¸ _mempty«_any«false»»¸ _mappend«->>«a1¸ a2¸ do«let«_any«b1»¸ a1»¸ let«_any«b2»¸ a2»¸ _any«||«b1¸ b2»»»»»»¸ Monoid«Sum¸ _mempty«_sum«0»»¸ _mappend«->>«s1¸ s2¸ do«let«_sum«n1»¸ s1»¸ let«_sum«n2»¸ s2»¸ _sum«+«n1¸ n2»»»»»»¸ Monoid«Prod¸ _mempty«_prod«1»»¸ _mappend«->>«p1¸ p2¸ do«let«_prod«n1»¸ p1»¸ let«_prod«n2»¸ p2»¸ _prod«*«n1¸ n2»»»»»»»»