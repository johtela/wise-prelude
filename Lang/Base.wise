Lang/BaseÂ«---Â«"# ðŸŽ“ Base Definitions

This module contains elementary definitions for built-in types, functions and macros, and JS interoperability."Â», defineÂ«---Â«"Macro returning Javascript `undefined` value."Â», _undefinedÂ«asmÂ«`undefined`Â»Â», ---Â«"If an expression expects the unit type (for example `while` expression) but you want to pass a value of a different type, you can reconciliate types with `_ignore` macro."Â», _ignoreÂ«->>Â«exp, doÂ«exp, ()Â»Â»Â», ---Â«"The identity macro returns its argument."Â», _idÂ«->>Â«val, valÂ»Â», ---Â«"## Mutable Type

The mutable type `&(a)` has two operators: dereference `^` and assignment `:=`"Â», ^Â«->>Â«&Â«aÂ», aÂ», ->>Â«mut, asmÂ«mutÂ»Â»Â», :=Â«->>Â«&Â«aÂ», a, aÂ», ->>Â«mut, val, asmÂ«mut, ` = `, valÂ»Â»Â»Â», defineÂ«---Â«"## Nullable Type


Here are few helper macros for nullable values. `?has` returns true if a value is not null. `?with` passes the value to a macro, if it's not null."Â», ?hasÂ«->>Â«?Â«aÂ», BoolÂ», ->>Â«val, asmÂ«val, ` != null`Â»Â»Â», ?withÂ«->>Â«?Â«aÂ», ->>Â«a, UnitÂ», UnitÂ», ->>Â«a, _mac, ifÂ«?hasÂ«aÂ», _macÂ«asmÂ«aÂ»Â»Â»Â»Â»Â», ---Â«"## Lazy Type

Lazy type is a generic function with no arguments. We provide an operator for defining lazy values (`\`), for evaluating (`\!`) and [memoizing](https://en.wikipedia.org/wiki/Memoization) (`\_`) them.
"Â», typeÂ«aliasÂ«LazyÂ«aÂ», ->Â«Unit, aÂ»Â»Â», defineÂ«\Â«->>Â«a, LazyÂ«aÂ»Â», ->>Â«expr, ->Â«_, exprÂ»Â»Â», \!Â«->>Â«LazyÂ«aÂ», aÂ», ->>Â«lazy, Â«lazy, ()Â»Â»Â», _memoizeÂ«->>Â«LazyÂ«aÂ», LazyÂ«aÂ»Â», ->>Â«lazy, doÂ«setÂ«memo, NullÂ», ->Â«_, matchÂ«^Â«memoÂ», |Â«?Â«vÂ», vÂ», |Â«_, doÂ«letÂ«val, \!Â«lazyÂ»Â», :=Â«memo, ?Â«valÂ»Â», valÂ»Â»Â»Â»Â»Â»Â», \_Â«->>Â«expr, _memoizeÂ«\Â«exprÂ»Â»Â»Â»Â», ---Â«"## Higher-order Functions and Macros"Â», defineÂ«---Â«"### Transforming Macros to Functions

Here are convenience macros for transforming macros of different arities to corresponding functions. Macros can't be stored in variables or returned from other macros. These transformations come in handy when we want to convert a macro to a storable value."Â», _tofunÂ«->>Â«->>Â«a, bÂ», ->Â«a, bÂ»Â», ->>Â«_mac, ->Â«a, _macÂ«aÂ»Â»Â»Â», _tofun2Â«->>Â«->>Â«a, b, cÂ», ->Â«a, b, cÂ»Â», ->>Â«_mac, ->Â«a, b, _macÂ«a, bÂ»Â»Â»Â», _tofun3Â«->>Â«->>Â«a, b, c, dÂ», ->Â«a, b, c, dÂ»Â», ->>Â«_mac, ->Â«a, b, c, _macÂ«a, b, cÂ»Â»Â»Â», _tofun4Â«->>Â«->>Â«a, b, c, d, eÂ», ->Â«a, b, c, d, eÂ»Â», ->>Â«_mac, ->Â«a, b, c, d, _macÂ«a, b, c, dÂ»Â»Â»Â»Â», defineÂ«---Â«"### Currying Functions


[Currying](https://en.wikipedia.org/wiki/Currying) transforms a function with multiple arguments to an unary function. Wise does not automatically curry functions, but you can do it explicitly using these macros."Â», #2Â«->>Â«fun, a, ->Â«b, funÂ«a, bÂ»Â»Â»Â», #3/1Â«->>Â«fun, a, ->Â«b, c, funÂ«a, b, cÂ»Â»Â»Â», #3/2Â«->>Â«fun, a, b, ->Â«c, funÂ«a, b, cÂ»Â»Â»Â», ---Â«"### Chaining Functions


The chaining operator `>->` is the same as Haskell's point (`.`) operator with arguments reversed. `f1 >-> f2` returns a function that applies first function `f1` and then function `f2` to a value."Â», >->Â«->>Â«f1, f2, ->Â«a, f2Â«f1Â«aÂ»Â»Â»Â»Â»Â», defineÂ«---Â«"### Fold Macros

Fold macros make writing expressions with binary operators easier; the same binary operator can be applied three or more arguments in one go."Â», _fold3Â«->>Â«_op, arg1, arg2, arg3, _opÂ«_opÂ«arg1, arg2Â», arg3Â»Â»Â», _fold4Â«->>Â«_op, arg1, arg2, arg3, arg4, _opÂ«_opÂ«_opÂ«arg1, arg2Â», arg3Â», arg4Â»Â»Â», _fold5Â«->>Â«_op, arg1, arg2, arg3, arg4, arg5, _opÂ«_opÂ«_opÂ«_opÂ«arg1, arg2Â», arg3Â», arg4Â», arg5Â»Â»Â», _fold6Â«->>Â«_op, arg1, arg2, arg3, arg4, arg5, arg6, _opÂ«_opÂ«_opÂ«_opÂ«_opÂ«arg1, arg2Â», arg3Â», arg4Â», arg5Â», arg6Â»Â»Â»Â», ---Â«"## Console Output

`_log` is the JS equivalent of `print` in other languages."Â», defineÂ«_logÂ«->>Â«a, UnitÂ», ->>Â«val, asmÂ«`console.log(`, val, `)`Â»Â»Â»Â»Â»